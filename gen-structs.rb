#! /usr/bin/env ruby

#Â create packed data structs

# run gen-bboxes.sh first if you need reverse lookup (location -> postcode) support, then:
# ./gen-structs.rb /path/to/codepoint-open/csv/files

puts "Opening, reading and parsing postcode files ..."

csvspath = ARGV[0] || '.'

pcs = []
csvs = File.join(csvspath, '*.csv')
foundAny = false
Dir[csvs].sort.each do |f|
  foundAny = true
  File.open(f).each_line.sort.each do |l|
    pc, q, e, n = l.split(',')
    pc = pc[1..-2]  # strip quotes

    unit = pc[-2..-1]
    sector = pc[-3]
    district = pc[0..-4].match(/[0-9][0-9A-Z]?/)[0]
    area = pc.match(/^[A-Z]+/)[0]
    
    unless q == '90'  # 90 means 'no location'
      pcs << { area: area, district: district, sector: sector, unit: unit, e: e.to_i, n: n.to_i, q: q } 
    end
  end
end

if !foundAny
  puts "No CSVs found at location '#{csvs}'"
  exit 1
end

outwardbboxes = File.exist?('outwardbboxes.csv') ?
  Hash[File.open('outwardbboxes.csv').each_line.map do |l|
    outwardcode, originE, originN, sizeE, sizeN = l.split(',')
    [outwardcode, [originE, originN, sizeE, sizeN].map(&:to_i)]
  end] : nil

puts ">> WARNING: no bounding boxes. Location -> postcode lookups will be unreliable. <<" if outwardbboxes.nil?

puts "Mapping symbols to save space ..."

area0Mapping = pcs.map { |p| p[:area][0] || "\0" }.uniq.sort
area1Mapping = pcs.map { |p| p[:area][1] || "\0" }.uniq.sort
district0Mapping = pcs.map { |p| p[:district][0] || "\0" }.uniq.sort
district1Mapping = pcs.map { |p| p[:district][1] || "\0" }.uniq.sort
sectorMapping = pcs.map { |p| p[:sector] || "\0" }.uniq.sort
unit0Mapping = pcs.map { |p| p[:unit][0] || "\0" }.uniq.sort
unit1Mapping = pcs.map { |p| p[:unit][1] || "\0" }.uniq.sort

def applyMappings(*args)
  result = 0
  runningMaxProduct = 1
  (0...args.length).step(2).each do |i|
    char = args[i]
    mapping = args[i + 1]
    value = mapping.index(char || "\0")
    result += value * runningMaxProduct
    runningMaxProduct *= mapping.count
  end
  result
end

puts "Creating lookup structures ..."

pcsByOutward = pcs.group_by { |p| p[:area] + p[:district] }; nil
pcsByOutwardMapped = pcsByOutward.map do |outward, pcs| 
  area = pcs.first[:area]  # since we grouped on this, first == all
  district = pcs.first[:district]  # ditto
  outwardCode = area + district
  outwardCodeMapped = applyMappings(
    district[1], district1Mapping,
    district[0], district0Mapping,
    area[1], area1Mapping,
    area[0], area0Mapping
  )
  [outwardCode, outwardCodeMapped, pcs]
end.sort_by { |p| p[0] }; nil  
# this sort _should_ be unnecessary, but 
# this can be checked like so: pcsByOutwardMapped.each_cons(2).all? { |a, b| a[0] < b[0] }

inwardCodesOffset = 0
outwardLookup = []
inwardLookup = []

pcsByOutwardMapped.each do |p|
  outwardCode, outwardCodeMapped, pcs = p
  if outwardbboxes.nil?
    originE = pcs.map { |pc| pc[:e]}.min
    originN = pcs.map { |pc| pc[:n]}.min
    maxOffsetE = pcs.map { |pc| pc[:e]}.max - originE
    maxOffsetN = pcs.map { |pc| pc[:n]}.max - originN
  else
    originE, originN, maxOffsetE, maxOffsetN = outwardbboxes[outwardCode]
  end
  outwardLookup << [outwardCodeMapped, originE, originN, maxOffsetE, maxOffsetN, inwardCodesOffset]
  inwardCodesOffset += pcs.count

  inwardPcsMapped = pcs.map do |pc| 
    sector = pc[:sector]
    unit = pc[:unit]  
    inwardCodeMapped = applyMappings(
      unit[1], unit1Mapping,
      unit[0], unit0Mapping,
      sector, sectorMapping
    )
    offsetE = pc[:e] - originE
    offsetN = pc[:n] - originN
    sectorMean = pc[:q] == '60' ? 1 : 0
    [inwardCodeMapped, offsetE, offsetN, sectorMean]
  end.sort_by { |p| p[0] }
  # this sort _should_ also be unnecessary, but let's go belt and braces

  inwardLookup.concat inwardPcsMapped
end; nil

puts "Generating C code ..."

def bitsRequiredFor(maxValue)
  Math.log2(maxValue + 1).ceil
end

typesC = "//
//  postcodeDataTypes.h
//  * THIS FILE IS AUTO-GENERATED BY A RUBY SCRIPT: EDIT THAT INSTEAD *
//
//  Created by George MacKerron on 14/01/2019.
//  Copyright (c) 2019 George MacKerron. All rights reserved.
//

#ifndef postcodeDataTypes_h
#define postcodeDataTypes_h

#ifdef DONT_PACK
#define PACKED
#else
#define PACKED __attribute__((packed))
#endif

typedef struct {
  unsigned int codeMapped : #{bitsRequiredFor(outwardLookup.map { |ol| ol[0] }.max)};
  unsigned int originE : #{bitsRequiredFor(outwardLookup.map { |ol| ol[1] }.max)};
  unsigned int originN : #{bitsRequiredFor(outwardLookup.map { |ol| ol[2] }.max)};
  unsigned int maxOffsetE : #{bitsRequiredFor(outwardLookup.map { |ol| ol[3] }.max)};
  unsigned int maxOffsetN : #{bitsRequiredFor(outwardLookup.map { |ol| ol[4] }.max)};
  unsigned int inwardCodesOffset : #{bitsRequiredFor(outwardLookup.map { |ol| ol[5] }.max)};
} PACKED OutwardCode;

typedef struct {
  unsigned int codeMapped : #{bitsRequiredFor(inwardLookup.map { |il| il[0] }.max)};
  unsigned int offsetE : #{bitsRequiredFor(inwardLookup.map { |il| il[1] }.max)};
  unsigned int offsetN : #{bitsRequiredFor(inwardLookup.map { |il| il[2] }.max)};
  bool sectorMean : 1;
} PACKED InwardCode;

#endif
"

dataC = "//
//  postcodes.data
//  * THIS FILE IS AUTO-GENERATED BY A RUBY SCRIPT: EDIT THAT INSTEAD *
//
//  Created by George MacKerron on 14/01/2019.
//  Copyright (c) 2019 George MacKerron. All rights reserved.
// 
//  Derived from Ordnance Survey CodePoint Open data
//  Contains OS data (C) Crown copyright and database right 2018
//  Contains Royal Mail data (C) Royal Mail copyright and database right 2018
//  Contains National Statistics data (C) Crown copyright and database right 2018
//

#include \"postcodeDataTypes.h\"

static const char area0Mapping[] = { #{area0Mapping.map{ |m| "'#{m == "\u0000" ? '\0' : m}'" }.join(',') } };
static const char area1Mapping[] = { #{area1Mapping.map{ |m| "'#{m == "\u0000" ? '\0' : m}'" }.join(',') } };
static const char district0Mapping[] = { #{district0Mapping.map{ |m| "'#{m == "\u0000" ? '\0' : m}'" }.join(',') } };
static const char district1Mapping[] = { #{district1Mapping.map{ |m| "'#{m == "\u0000" ? '\0' : m}'" }.join(',') } };
static const char sectorMapping[] = { #{sectorMapping.map{ |m| "'#{m == "\u0000" ? '\0' : m}'" }.join(',') } };
static const char unit0Mapping[] = { #{unit0Mapping.map{ |m| "'#{m == "\u0000" ? '\0' : m}'" }.join(',') } };
static const char unit1Mapping[] = { #{unit1Mapping.map{ |m| "'#{m == "\u0000" ? '\0' : m}'" }.join(',') } };

static const OutwardCode outwardCodes[] = {
#{outwardLookup.map { |l| '{' + l.map(&:to_s).join(',') + '}' }.join(",\n")}
};

static const InwardCode inwardCodes[] = {
#{inwardLookup.map { |l| '{' + l.map(&:to_s).join(',') + '}' }.join(",\n")}
};
"

puts "Writing C code ..."

typesFile = File.join('postcodes', 'postcodeDataTypes.h')
puts typesFile
File.write(typesFile, typesC)

dataFile = File.join('postcodes', 'postcodes.data')
puts dataFile
File.write(dataFile, dataC)

puts "Done."
